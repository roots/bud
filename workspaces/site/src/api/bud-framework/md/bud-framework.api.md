## API Report File for "@roots/bud-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="express-serve-static-core" />
/// <reference types="node" />

import type { Class } from 'type-fest';
import { Compiler as Compiler_2 } from 'webpack';
import { Configuration } from 'webpack';
import { Container } from '@roots/container';
import { DefaultMethods } from 'signale';
import type { HighlightOptions } from '@roots/bud-support';
import { IncomingMessage } from 'http';
import type Ink from 'ink';
import { MultiCompiler } from 'webpack';
import { Options as Options_4 } from 'http-proxy-middleware';
import type { PrettyFormatOptions } from '@roots/bud-support';
import { PrettyFormatOptions as PrettyFormatOptions_2 } from 'pretty-format/build/types';
import { ProgressPlugin } from 'webpack';
import { RuleSetRule } from 'webpack';
import { Server as Server_2 } from 'http';
import { ServerResponse } from 'http';
import { Signale } from '@roots/bud-support';
import { Signale as Signale_2 } from 'signale';
import { SignaleConfig } from 'signale';
import { SignaleOptions } from 'signale';
import { Stats } from 'webpack';
import { StatsCompilation } from 'webpack';
import { StatsError } from 'webpack';
import { URL as URL_2 } from 'url';
import { ValueOf } from 'type-fest';
import * as Webpack from 'webpack';
import { default as Webpack_2 } from 'webpack';

// Warning: (ae-internal-missing-underscore) The name "Api" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Api<T = Record<string, (...args: unknown[]) => Framework>> extends Service<T> {
    // (undocumented)
    bindFacade: (key: `${keyof Api['repository'] & string}`) => void;
    // (undocumented)
    call: (name: string, ...args: any[]) => Promise<void>;
    // (undocumented)
    processQueue: () => Promise<void>;
    // (undocumented)
    queue: Array<[string, ...any[]]>;
    // (undocumented)
    trace: Array<[string, ...any[]]>;
}

// @public
interface Application extends Loose {
    // (undocumented)
    listen(on: string | number, cb: CallableFunction): Instance;
}

// @public
export interface AsyncFactory<P extends any[], T> {
    // (undocumented)
    (...args: P): Promise<T>;
}

// @public
export type AtLeastOne<Type = unknown> = Type | Type[];

// Warning: (ae-forgotten-export) The symbol "GenericFunctionMap" needs to be exported by the entry point index.d.ts
//
// @public
function bindMethod<FunctionMap = GenericFunctionMap>(properties: FunctionMap): Framework;

// @public (undocumented)
interface bindMethod {
    // (undocumented)
    <FunctionMap = GenericFunctionMap>(properties: FunctionMap): Framework;
}

// @public
export abstract class Bootstrapper<T = any> extends Container<T> {
    constructor(app: Framework);
    get app(): Framework;
    abstract ident?: string;
}

declare namespace Build {
    export {
        Build_2 as Interface,
        Build_3 as Abstract
    }
}
export { Build }

// @public
interface Build_2 extends Service {
    config: Webpack.Configuration;
    items: Items;
    loaders: Loaders;
    make(): Promise<Webpack.Configuration>;
    makeRule(constructorProperties?: Partial<Rule.Options>): Rule.Interface;
    rules: Rules;
    setRule(name: string, constructorProperties?: Partial<Rule.Options>): Rule.Interface;
}

// @public
abstract class Build_3 extends Service {
    items: Item.Interface[];
    loaders: Loader.Interface[];
    abstract make: () => Webpack.Configuration;
    rules: Rule.Interface[];
}

declare namespace Cache_2 {
    export {
        CacheInterface as Interface,
        CacheAbstract as Abstract
    }
}
export { Cache_2 as Cache }

// @public
abstract class CacheAbstract extends Service implements CacheInterface {
    abstract directory: string;
    abstract hashFileContents(filePaths: Array<string>): Promise<string>;
    abstract version: string;
}

// @public
interface CacheInterface extends Service {
    directory: string;
    hashFileContents(str: Array<string>): Promise<string>;
    version: string;
}

// @public
function close_2(done?: (code?: number) => never): void;

// @public
interface close_2 {
    // (undocumented)
    (done?: CallableFunction): void;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Compiler" because one of its declarations is marked as @internal
//
// @public
export interface Compiler extends Service {
    before(): any;
    callback(err: StatsError, stats: StatsCompilation): void;
    compile(): Promise<any>;
    instance: Compiler.Instance;
    isCompiled: boolean;
    progress: Compiler.Progress;
    stats: StatsCompilation;
}

// @internal
export namespace Compiler {
    // (undocumented)
    export type Config = Configuration;
    // (undocumented)
    export type Instance = Compiler_2 | MultiCompiler;
    // (undocumented)
    export type Progress = any;
    // (undocumented)
    export namespace Progress {
        // (undocumented)
        export type Handler = ProgressPlugin['handler'];
    }
}

// @public
interface CompilerPlugin<Plugin = any, Options = Record<string, any>> extends Module_2 {
    apply?: CallableFunction;
    make?: Maybe<[Container<Options>, Framework, Signale], Plugin>;
}

// @public
interface Configuration_2 {
    browser: {
        log: boolean;
        indicator: boolean;
        overlay: boolean;
    };
    dev: {
        url: URL_2;
    };
    disableHostCheck?: boolean;
    filename?: string;
    middleware: Record<string, boolean>;
    proxy: {
        url: URL_2;
    };
    publicPath?: string;
    watch: {
        files: Array<string>;
    };
}

// @public
export type Constructor = new (options: Options) => Framework;

// @public
interface ConstructorOptions {
    loader: Maybe<[Framework], Loader.Interface>;
    options?: Maybe<[Framework], Options_2>;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "container" because one of its declarations is marked as @internal
//
// @internal
interface container<T = any> {
    // (undocumented)
    <T>(repository?: T): Container<T>;
}

// @public
const container: <T = any>(repository?: T) => Container<T>;

// @public
export interface Dashboard extends Service {
    instance: Ink.Instance;
    render(Component: any, title?: string): void;
    rerender(): Promise<void>;
    run(): void;
    // (undocumented)
    stderr?: Array<string>;
    // (undocumented)
    stdout?: Array<string>;
}

// @public
export interface Dependencies extends Service {
    client: any;
    install(dependencies: {
        name: string;
        version: string;
    }[]): Promise<void>;
}

// @public
export interface Env extends Container {
    getPublicEnv(): Index<any>;
}

declare namespace Extension {
    export {
        Name,
        CompilerPlugin,
        Module_2 as Module
    }
}
export { Extension }

// @public
export interface Extensions extends Service {
    add(extension: CompilerPlugin | Module_2): Promise<void>;
    bootExtensions(): Promise<void>;
    // (undocumented)
    enqueue(extension: CompilerPlugin | Module_2): Framework;
    injectExtensions(): Promise<void>;
    make(): Promise<{
        [key: string]: any;
        apply: CallableFunction;
    }[]>;
    // (undocumented)
    processQueue(): Promise<void>;
    queue: Array<CompilerPlugin | Module_2>;
    registerExtensions(): Promise<void>;
}

// @public
export interface Factory<P extends any[], T> {
    // (undocumented)
    (...args: P): T;
}

// @public
interface Factory_2 {
    // (undocumented)
    (app: Framework): LoaderInterface;
}

// @public
export abstract class Framework {
    constructor(options: Options);
    // Warning: (ae-incompatible-release-tags) The symbol "api" is marked as @public, but its signature references "Api" which is marked as @internal
    api: Api;
    await(...messages: any[]): this;
    bindMethod: methods.bindMethod;
    build: Build.Interface;
    cache: Cache_2.Interface;
    children: Container<Record<string, Framework>>;
    close: methods.close;
    compiler: Compiler;
    complete(...messages: any[]): this;
    container: methods.container;
    dashboard: Dashboard;
    debug(...messages: any[]): void;
    dependencies: Dependencies;
    // (undocumented)
    dump(obj: any, options?: PrettyFormatOptions & HighlightOptions & {
        prefix: string;
    }): Framework;
    env: Env;
    error(...messages: any[]): this;
    extensions: Extensions;
    get: methods.get;
    get hasChildren(): boolean;
    hooks: Hooks;
    // @internal @virtual
    abstract implementation: Constructor;
    info(...messages: any[]): this;
    get isChild(): boolean;
    get isDevelopment(): boolean;
    get isProduction(): boolean;
    get isRoot(): boolean;
    // Warning: (ae-forgotten-export) The symbol "parser" needs to be exported by the entry point index.d.ts
    json: typeof parser.json;
    // Warning: (ae-forgotten-export) The symbol "lifecycle" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    lifecycle: lifecycle;
    log(...messages: any[]): this;
    logger: Logger;
    make: methods.make;
    // Warning: (ae-forgotten-export) The symbol "methods" needs to be exported by the entry point index.d.ts
    maybeCall: methods.maybeCall;
    mixin: typeof methods.mixin;
    get mode(): Mode;
    set mode(mode: Mode);
    get name(): string;
    set name(name: string);
    options: Options;
    path: methods.path;
    pipe: methods.pipe;
    project: Project;
    root: Framework | null;
    sequence: methods.sequence;
    // (undocumented)
    get server(): Server.Interface;
    set server(server: Server.Interface);
    _server: Server.Interface;
    services: Services;
    setPath: methods.setPath;
    store: Store;
    success(...messages: any[]): this;
    tap: methods.tap;
    time(...messages: any[]): this;
    timeEnd(...messages: any[]): this;
    ts: typeof parser.ts;
    usingTsNode: boolean;
    warn(...messages: any[]): this;
    when: methods.when;
    yml: typeof parser.yml;
}

// @public (undocumented)
interface get {
    // (undocumented)
    (this: Framework, name: string, tap?: (app: Framework) => Framework): Framework;
}

// @public (undocumented)
interface get {
    // (undocumented)
    (name: string, tap?: (app: Framework) => Framework): Framework;
}

// @public
const get: get;

// @public
export interface Hooks extends Service {
    async<T extends keyof Hooks.Map & string>(id: T, callback?: (param?: Hooks.Map[T]) => Promise<Hooks.Map[T]>): Framework;
    filter<T extends keyof Hooks.Map & string>(id: T, value?: Hooks.Map[T] | ((value?: Hooks.Map[T]) => Hooks.Map[T])): Hooks.Map[T];
    filterAsync<T extends keyof Hooks.Map & string>(id: T, value?: Hooks.Map[T] | ((param?: Hooks.Map[T]) => Promise<Hooks.Map[T]>)): Promise<Hooks.Map[T]>;
    on<T extends keyof Hooks.Map & string>(id: T, callback?: (param?: Hooks.Map[T]) => Hooks.Map[T]): Framework;
}

// @public (undocumented)
export namespace Hooks {
    export type Hook<T extends keyof Map & string> = ((value?: T) => Map[T]) | ((value?: T) => Partial<Map[T]>) | Map[T] | Partial<Map[T]>;
    export type LimitedEntryObject = Record<string, {
        import?: string[];
        dependsOn?: string[];
    }>;
    export type LimitedPlugin = Array<{
        apply: any;
    }>;
    // (undocumented)
    export interface Map {
        // (undocumented)
        [`build.bail`]: boolean;
        // (undocumented)
        [`build.cache`]: any;
        // (undocumented)
        ['build.cache.buildDependencies']: Record<string, Array<string>>;
        // (undocumented)
        ['build.cache.cacheDirectory']: string;
        // (undocumented)
        ['build.cache.managedPaths']: Array<string>;
        // (undocumented)
        ['build.cache.type']: 'memory' | 'filesystem';
        // (undocumented)
        [`build.cache.version`]: string;
        // (undocumented)
        [`build.context`]: Configuration['context'];
        // (undocumented)
        [`build.devtool`]: Configuration['devtool'];
        // (undocumented)
        [`build.entry`]: LimitedEntryObject;
        // (undocumented)
        [`build.experiments`]: Configuration['experiments'];
        // (undocumented)
        [`build.externals`]: Configuration['externals'];
        // (undocumented)
        [`build.infrastructureLogging`]: Configuration['infrastructureLogging'];
        // (undocumented)
        [`build.mode`]: Configuration['mode'];
        // (undocumented)
        [`build.module`]: Configuration['module'];
        // (undocumented)
        [`build.module.rules`]: Configuration['module']['rules'];
        // (undocumented)
        [`build.module.rules.after`]: Array<RuleSetRule>;
        // (undocumented)
        [`build.module.rules.before`]: Array<RuleSetRule>;
        // (undocumented)
        [`build.module.rules.oneOf`]: Array<RuleSetRule>;
        // (undocumented)
        [`build.name`]: Configuration['name'];
        // (undocumented)
        [`build.node`]: Configuration['node'];
        // (undocumented)
        [`build.optimization`]: Configuration['optimization'];
        // (undocumented)
        [`build.optimization.emitOnErrors`]: Configuration['optimization']['emitOnErrors'];
        // (undocumented)
        [`build.optimization.minimize`]: Configuration['optimization']['minimize'];
        // (undocumented)
        [`build.optimization.minimizer`]: Configuration['optimization']['minimizer'];
        // (undocumented)
        [`build.optimization.moduleIds`]: Configuration['optimization']['moduleIds'];
        // (undocumented)
        [`build.optimization.removeEmptyChunks`]: Configuration['optimization']['removeEmptyChunks'];
        // (undocumented)
        [`build.optimization.runtimeChunk`]: Configuration['optimization']['runtimeChunk'];
        // (undocumented)
        [`build.optimization.splitChunks`]: any;
        // (undocumented)
        [`build.output`]: Configuration['output'];
        // (undocumented)
        [`build.output.assetModuleFilename`]: Configuration['output']['assetModuleFilename'];
        // (undocumented)
        [`build.output.chunkFilename`]: Configuration['output']['chunkFilename'];
        // (undocumented)
        [`build.output.clean`]: Configuration['output']['clean'];
        // (undocumented)
        [`build.output.filename`]: Configuration['output']['filename'];
        // (undocumented)
        [`build.output.path`]: Configuration['output']['path'];
        // (undocumented)
        [`build.output.pathinfo`]: Configuration['output']['pathinfo'];
        // (undocumented)
        [`build.output.publicPath`]: string;
        // (undocumented)
        [`build.parallelism`]: Configuration['parallelism'];
        // (undocumented)
        [`build.performance`]: Configuration['performance'];
        // (undocumented)
        [`build.plugins`]: LimitedPlugin;
        // (undocumented)
        [`build.profile`]: Configuration['profile'];
        // (undocumented)
        [`build.recordsPath`]: Configuration['recordsPath'];
        // (undocumented)
        [`build.resolve`]: Configuration['resolve'];
        // (undocumented)
        [`build.resolve.alias`]: {
            [index: string]: string | false | string[];
        };
        // (undocumented)
        [`build.resolve.extensions`]: Configuration['resolve']['extensions'];
        // (undocumented)
        [`build.resolve.modules`]: Configuration['resolve']['modules'];
        // (undocumented)
        [`build.stats`]: Configuration['stats'];
        // (undocumented)
        [`build.target`]: Configuration['target'];
        // (undocumented)
        [`build.watch`]: Configuration['watch'];
        // (undocumented)
        [`build.watchOptions`]: Configuration['watchOptions'];
        // (undocumented)
        [`config.override`]: Configuration[];
        // (undocumented)
        [`event.app.close`]: unknown;
        // (undocumented)
        [`event.build.make.after`]: unknown;
        // (undocumented)
        [`event.build.make.before`]: unknown;
        // (undocumented)
        [`event.build.override`]: Configuration;
        // (undocumented)
        [`event.compiler.after`]: Framework;
        // (undocumented)
        [`event.compiler.before`]: Array<Framework>;
        // (undocumented)
        [`event.compiler.done`]: Stats;
        // (undocumented)
        [`event.compiler.error`]: Error;
        // (undocumented)
        [`event.compiler.stats`]: StatsCompilation;
        // (undocumented)
        [`event.dashboard.c`]: void;
        // (undocumented)
        [`event.dashboard.done`]: void;
        // (undocumented)
        [`event.dashboard.q`]: void;
        // (undocumented)
        [`event.project.write`]: Framework['project'];
        // (undocumented)
        [`event.run`]: Framework;
        // (undocumented)
        [`event.server.after`]: Framework;
        // (undocumented)
        [`event.server.before`]: Framework;
        // (undocumented)
        [`event.server.listen`]: Framework['server'];
        // (undocumented)
        [`location.dist`]: string;
        // (undocumented)
        [`location.modules`]: string;
        // (undocumented)
        [`location.project`]: string;
        // (undocumented)
        [`location.src`]: string;
        // (undocumented)
        [`location.storage`]: string;
        // (undocumented)
        [`proxy.interceptor`]: (buffer: Buffer, proxyRes: IncomingMessage, req: IncomingMessage, res: ServerResponse) => Promise<Buffer | string>;
        // (undocumented)
        [`proxy.options`]?: Options_4;
        // (undocumented)
        [`proxy.replace`]: Array<[string | RegExp, string]>;
        // (undocumented)
        [`proxy.target`]: string;
        // (undocumented)
        [`server.inject`]?: Array<(app: Framework) => string>;
        // (undocumented)
        [`server.middleware`]?: Record<string, (app: Framework) => Express.Response>;
        // (undocumented)
        [key: `extension.${string}`]: any;
        // (undocumented)
        [`build`]: Record<string, any>;
        // (undocumented)
        [`extension`]: ValueOf<Plugins> | ValueOf<Modules>;
    }
        {};
}

// @public
export type Index<T = any> = {
    [key: string]: T;
};

// @public
interface Instance extends Server_2 {
}

// @public (undocumented)
interface Interface {
    app: Framework;
    exclude?: (app: Framework) => RegExp;
    generator?: (app: Framework) => any;
    getExclude(): RegExp;
    getGenerator(): any;
    getInclude(): string;
    getParser(): Parser;
    getTest(): RegExp;
    getType(): string;
    getUse(): Item.Interface[];
    include?: (app: Framework) => string;
    make(): Output_2;
    normalizeInput: (input: () => any | any) => any;
    parser?: (app: Framework) => Parser;
    setExclude(exclude: Maybe<[Framework], RegExp>): Rule.Interface;
    setGenerator(Generator: ((app: Framework) => Rule.Interface['generator']) | Rule.Interface['generator']): Rule.Interface;
    setInclude(include: Maybe<[Framework], string>): Rule.Interface;
    setParser(parser: Maybe<[Framework], Parser>): Rule.Interface;
    setTest(test: Maybe<[Framework], RegExp>): Rule.Interface;
    setType(type: Maybe<[Framework], string>): Rule.Interface;
    setUse(use: Maybe<[Framework], Item.Interface[]>): Rule.Interface;
    test?: (app: Framework) => RegExp;
    type?: (app: Framework) => string;
    use?: (app: Framework) => Item.Interface[];
}

// @public
interface Interface_2 extends Service {
    application: Application;
    close(): any;
    config: Store.Repository['server'];
    instance: Instance;
    middleware: Middleware;
    port: string;
    run(): Promise<this>;
    watcher: {
        getWatchedFiles(): Promise<Array<string>>;
        watch(): Promise<void>;
    };
}

declare namespace Item {
    export {
        Item_2 as Interface,
        Item_3 as Abstract,
        Options_2 as Options,
        ConstructorOptions,
        Output
    }
}
export { Item }

// @public
interface Item_2 {
    loader: Factory<[Framework], Loader.Interface>;
    make(app: Framework): Output;
    mergeOptions(options: Options_2, app: Framework): void;
    options: Options_2;
    setLoader(factory: Maybe<[Framework], Loader.Interface>): void;
    setOptions(factory: Maybe<[Framework], Options_2>): void;
}

// @public
abstract class Item_3 {
    abstract loader: Factory<[Framework], Loader.Interface>;
    abstract make(app: Framework): Output;
    abstract mergeOptions(options: Options_2, app: Framework): void;
    abstract options: Factory<[Framework], Options_2>;
    abstract setLoader(factory: Maybe<[Framework], Loader.Interface>): void;
    abstract setOptions(factory: Maybe<[Framework], Options_2>): void;
}

// @public @virtual
export interface Items extends Partial<Index<Item.Interface>> {
}

declare namespace json {
    export {
        read,
        write
    }
}

declare namespace Loader {
    export {
        LoaderInterface as Interface,
        LoaderAbstract as Abstract,
        Factory_2 as Factory
    }
}
export { Loader }

// @public
abstract class LoaderAbstract implements LoaderInterface {
    abstract make(app: Framework): string;
    abstract normalizeInput<T = any>(input: Maybe<[Framework], T>): Factory<[Framework], T>;
    abstract src: Factory<[Framework], string>;
}

// @public
interface LoaderInterface {
    make(app: Framework): string;
    normalizeInput<T = any>(input: Maybe<[Framework], T>): Factory<[Framework], T>;
    src: Factory<[Framework], string>;
}

// @public @virtual
export interface Loaders extends Partial<Index<Loader.Interface>> {
}

// @public @virtual
export interface Locations extends Partial<Record<string, string>> {
    // (undocumented)
    [key: string]: string;
    // (undocumented)
    dist?: string;
    // (undocumented)
    project?: string;
    // (undocumented)
    src?: string;
}

// @public
export class Logger {
    constructor(app: Framework);
    // Warning: (ae-forgotten-export) The symbol "INSTANCE_CONFIG" needs to be exported by the entry point index.d.ts
    config: INSTANCE_CONFIG;
    get context(): Array<string>;
    get enabled(): boolean;
    get flags(): Record<string, any>;
    instance: Signale;
    // (undocumented)
    instantiate(): void;
    get interactive(): boolean;
    get level(): string;
    // (undocumented)
    makeInstance(options?: SignaleOptions, config?: SignaleConfig): Signale_2<DefaultMethods>;
    // (undocumented)
    options: SignaleOptions;
    scoped(...scope: Array<string>): Signale_2<DefaultMethods>;
    secrets: Array<string>;
    stream: (NodeJS.WriteStream & {
        fd: 1;
    })[];
}

// @public
export interface Loose {
    // (undocumented)
    [key: string]: any;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "make" because one of its declarations is marked as @internal
//
// @public
function make(name: string, tap?: (app: Framework) => any): Promise<Framework>;

// @internal
interface make {
    // (undocumented)
    (name: string, tap?: (app: Framework) => any): Promise<Framework>;
}

// @public
export type Maybe<A extends any[], T> = T | Factory<A, T>;

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "maybeCall" because one of its declarations is marked as @internal
//
// @public
function maybeCall<I = any>(value: (app: Framework) => I | I): any;

// @internal (undocumented)
interface maybeCall<I = any> {
    // (undocumented)
    (value: ((app: Framework) => I) | I): I;
}

// @public
interface Middleware {
    // (undocumented)
    [key: string]: any;
}

// Warning: (ae-forgotten-export) The symbol "GenericClassMap" needs to be exported by the entry point index.d.ts
//
// @public
function mixin<ClassMap = GenericClassMap>(properties: ClassMap): void;

// @public
export type Mode = 'production' | 'development';

// @public @deprecated
export interface Module<P = any, O = any> extends Extension.Module<O> {
}

// @public
interface Module_2<Options = any> extends Loose {
    api?: ((app: Framework) => Promise<Record<string, CallableFunction>>) | Record<string, CallableFunction>;
    boot?: Factory<[Framework, Signale], any>;
    mixin?: (app: Framework) => Promise<Record<string, any>>;
    name?: Name;
    options?: Maybe<[Framework], Options>;
    register?: Factory<[Framework, Signale], any>;
    when?: Maybe<[Framework, Container<Options>], boolean>;
}

// @public @virtual
export interface Modules extends Partial<Index<Extension.Module>> {
}

// @public
type Name = `${(keyof Modules & string) | (keyof Plugins & string)}`;

// @public (undocumented)
export interface Options {
    // @internal (undocumented)
    childOf?: Framework;
    config?: Partial<Store['repository']>;
    extensions?: () => Record<string, Extension.Module | Extension.CompilerPlugin>;
    services?: Services;
}

// @public
interface Options_2 {
    // (undocumented)
    [key: string]: any;
}

// @public
type Options_3 = Partial<{
    test: Maybe<Array<Framework>, RegExp>;
    use: Maybe<Array<Framework>, Array<Item.Interface>>;
    include: Maybe<Array<Framework>, string>;
    exclude: Maybe<Array<Framework>, RegExp>;
    type: Maybe<Array<Framework>, string>;
    parser: Maybe<Array<Framework>, Parser>;
    generator: Maybe<Array<Framework>, any>;
}>;

// @public
interface Output {
    loader: string;
    options?: Options_2;
}

// @public
type Output_2 = Partial<{
    test: RegExp;
    use?: {
        loader: string;
        options?: {
            [key: string]: any;
        };
    }[];
    exclude?: RegExp;
    type?: string;
    parser?: Parser;
    generator?: any;
}>;

// @public
interface Parser extends Record<string, any> {
}

// @public (undocumented)
interface path {
    // (undocumented)
    (this: Framework, key: keyof Locations & string, ...path: string[]): string;
}

// @public (undocumented)
interface path {
    // (undocumented)
    (key: `${keyof Locations & string}`, ...path: string[]): string;
}

// @public (undocumented)
const path: path;

// @public
export interface Peers {
    adjacents: any;
    app: Framework;
    discover(type: 'dependencies' | 'devDependencies'): Promise<this>;
    getManifest(name: string): Promise<Record<string, any>>;
    hasMissingDependencies: boolean;
    peerDependencies: Map<string, string>;
    resolveModulePath(name: string): Promise<string>;
}

// Warning: (ae-forgotten-export) The symbol "Callback" needs to be exported by the entry point index.d.ts
//
// @public
function pipe<T = Framework>(fns: Callback<T>[], value?: T): T;

// @public (undocumented)
interface pipe {
    // (undocumented)
    <T = Framework>(fns: Callback<T>[], value?: T): T;
}

// @public
export interface PluginInstance {
    apply: CallableFunction;
}

// @public @virtual
export interface Plugins extends Partial<Index<Extension.CompilerPlugin>> {
}

// @public
export interface Project extends Service {
    // (undocumented)
    [key: string]: any;
    buildProfile(): Promise<any>;
    buildProfile(): Promise<any>;
    hasPeerDependency(pkg: string): boolean;
    peers: Peers;
    writeProfile(): Promise<any>;
}

// @public (undocumented)
const read: (file: string) => Promise<any>;

// @public (undocumented)
function read_2(path: string): Promise<any>;

// @public (undocumented)
const read_3: (file: string) => Promise<any>;

declare namespace Rule {
    export {
        Parser,
        Options_3 as Options,
        Output_2 as Output,
        Interface
    }
}
export { Rule }

// @public @virtual
export interface Rules extends Partial<Record<string, Rule.Interface>> {
}

// Warning: (ae-forgotten-export) The symbol "Callback" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function sequence<T = Framework>(fns: Callback_2[], value?: T): Framework;

// @public (undocumented)
interface sequence {
    // (undocumented)
    <T = Framework>(fns: Callback_2[], value?: T): Framework;
}

declare namespace Server {
    export {
        Application,
        Instance,
        Middleware,
        Options_4 as ProxyOptions,
        Interface_2 as Interface,
        Configuration_2 as Configuration
    }
}
export { Server }

// @public
export abstract class Service<Repository = Record<string, any>> extends Bootstrapper<Repository> {
    // @virtual
    boot?(app: Framework): Promise<any>;
    // @virtual
    booted?(app: Framework): Promise<any>;
    // @virtual
    bootstrap?(app: Framework): Promise<any>;
    // @virtual
    bootstrapped?(app: Framework): Promise<any>;
    dump(options?: PrettyFormatOptions_2): void;
    ident?: string;
    log(type: string, ...messages: any[]): this;
    get logger(): Logger['instance'];
    // @virtual
    register?(app: Framework): Promise<any>;
    // @virtual
    registered?(app: Framework): Promise<any>;
}

// @public @virtual
export interface Services extends Partial<Record<string, new (app: Framework) => Service>> {
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "setPath" because one of its declarations is marked as @internal
//
// @public
function setPath(...args: any[]): Framework;

// @internal
interface setPath {
    // (undocumented)
    (...args: any[]): Framework;
}

// @public
export class Store<T = Store.Repository> extends Service<T> {
    constructor(app: Framework, options: Partial<Store.Repository>);
    // @override
    get<K extends keyof Store.Map & string, T = Store.Map[K]>(path: K): T;
    ident: string;
    // @override
    set<K extends keyof Store.Map & string, T = Store.Map[K]>(path: K, value: T): this;
}

// @public (undocumented)
export namespace Store {
    // (undocumented)
    export type BuildKeyMap = {
        ['build.bail']: boolean;
        [`build.cache`]: any;
        ['build.cache.buildDependencies']: Record<string, Array<string>>;
        ['build.cache.cacheDirectory']: string;
        [`build.cache.version`]: string;
        ['build.cache.type']: 'memory' | 'filesystem';
        ['build.cache.managedPaths']: Array<string>;
        [`build.context`]: Repository['build']['context'];
        [`build.devtool`]: Repository['build']['devtool'];
        [`build.entry`]: Repository['build']['entry'];
        [`build.experiments`]: Repository['build']['experiments'];
        [`build.externals`]: Repository['build']['externals'];
        [`build.infrastructureLogging`]: Repository['build']['infrastructureLogging'];
        [`build.mode`]: Repository['build']['mode'];
        [`build.module`]: Repository['build']['module'];
        [`build.name`]: Repository['build']['name'];
        [`build.node`]: Repository['build']['node'];
        [`build.optimization`]: Repository['build']['optimization'];
        [`build.optimization.emitOnErrors`]: Repository['build']['optimization']['emitOnErrors'];
        [`build.optimization.minimize`]: Repository['build']['optimization']['minimize'];
        [`build.optimization.minimizer`]: Repository['build']['optimization']['minimizer'];
        [`build.optimization.moduleIds`]: Repository['build']['optimization']['moduleIds'];
        [`build.optimization.removeEmptyChunks`]: Repository['build']['optimization']['removeEmptyChunks'];
        [`build.optimization.runtimeChunk`]: Repository['build']['optimization']['runtimeChunk'];
        [`build.optimization.splitChunks`]: any;
        [`build.output`]: Repository['build']['output'];
        [`build.output.assetModuleFilename`]: Repository['build']['output']['assetModuleFilename'];
        [`build.output.chunkFilename`]: Repository['build']['output']['chunkFilename'];
        [`build.output.clean`]: Repository['build']['output']['clean'];
        [`build.output.filename`]: Repository['build']['output']['filename'];
        [`build.output.path`]: Repository['build']['output']['path'];
        [`build.output.pathinfo`]: Repository['build']['output']['pathinfo'];
        [`build.output.publicPath`]: string;
        [`build.parallelism`]: Repository['build']['parallelism'];
        [`build.performance`]: Repository['build']['performance'];
        [`build.profile`]: Repository['build']['profile'];
        [`build.recordsPath`]: Repository['build']['recordsPath'];
        [`build.resolve`]: Repository['build']['resolve'];
        [`build.resolve.alias`]: Record<string, string | false | string[]>;
        [`build.resolve.extensions`]: Repository['build']['resolve']['extensions'];
        [`build.resolve.modules`]: Repository['build']['resolve']['modules'];
        [`build.stats`]: Repository['build']['stats'];
        [`build.target`]: Repository['build']['target'];
        [`build.watch`]: Repository['build']['watch'];
        [`build.watchOptions`]: Repository['build']['watchOptions'];
    };
    // (undocumented)
    export type CliFlagsKeyMap = {
        [K in keyof Repository['cli']['flags'] as `cli.flags.${K & string}`]: Repository['cli']['flags'][K];
    };
    // (undocumented)
    export type CliKeyMap = {
        [K in keyof Repository['cli'] as `cli.${K & string}`]: Repository['cli'][K];
    };
    // (undocumented)
    export type FeaturesKeyMap = {
        [K in keyof Repository['features'] as `features.${K & string}`]: Repository['features'][K];
    };
    // (undocumented)
    export type LocationKeyMap = {
        [K in keyof Repository['location'] as `location.${K & string}`]: Repository['location'][K];
    };
    // (undocumented)
    export interface Map extends BuildKeyMap, RepositoryKeyMap, CliKeyMap, CliFlagsKeyMap, FeaturesKeyMap, LocationKeyMap, PatternKeyMap, ServerKeyMap, ThemeKeyMap, ThemeColorsKeyMap {
        // (undocumented)
        ['cache.type']: Repository['cache']['type'];
        // (undocumented)
        ['log.level']: Repository['log']['level'];
    }
    // (undocumented)
    export type PatternKeyMap = {
        [K in PatternKeys as `patterns.${K & string}`]: Repository['patterns'][K];
    };
    // (undocumented)
    export type PatternKeys = 'js' | 'css' | 'font' | 'image' | 'modules' | 'html' | 'ts' | 'sass' | 'cssModule' | 'sassModule' | 'svg' | 'vue' | 'md' | 'json' | 'json5' | 'toml' | 'yml' | 'xml' | 'csv' | 'webp';
    export interface Repository {
        // Warning: (ae-forgotten-export) The symbol "CompilerConfig" needs to be exported by the entry point index.d.ts
        build: CompilerConfig;
        cache: {
            type?: 'filesystem' | 'memory' | false;
        };
        // (undocumented)
        cli?: {
            args: Record<string, any>;
            argv: Array<string>;
            flags: Record<string, any>;
            raw: Array<Record<string, string>>;
            metadata: Record<string, Record<string, any>>;
        };
        features: {
            cache?: boolean;
            dashboard?: boolean;
            clean?: boolean;
            hash?: boolean;
            html?: boolean;
            inject?: boolean;
            install?: boolean;
            log?: boolean;
            manifest?: boolean;
            proxy?: boolean;
            runtimeChunk?: boolean;
            splitChunks?: boolean;
        };
        fileFormat: string;
        hashFormat: string;
        location: Locations;
        log?: {
            level?: 'v' | 'vv' | 'vvv' | 'vvvv';
        };
        mode: 'production' | 'development';
        name: string;
        patterns: Record<string, RegExp>;
        server: Server.Configuration;
        theme: {
            spacing: number;
            colors: {
                foreground: TermColor;
                faded: TermColor;
                primary: TermColor;
                primaryAlt: TermColor;
                error: TermColor;
                errorAlt: TermColor;
                warning: TermColor;
                success: TermColor;
                accent: TermColor;
                flavor: TermColor;
            };
            screens: [
            [
            number,
            number
            ],
            [
            number,
            number
            ],
            [
            number,
            number
            ],
            [
            number,
            number
            ]
            ];
            columns: number;
            maxWidth: number;
            maxHeight: number;
        };
    }
    // (undocumented)
    export type RepositoryKeyMap = {
        [K in keyof Repository as `${K & string}`]: Repository[K];
    };
    // (undocumented)
    export type ServerKeyMap = {
        ['server']: Repository['server'];
        ['server.dev']: Repository['server']['dev'];
        ['server.proxy']: Repository['server']['proxy'];
        ['server.watch']: Repository['server']['watch'];
        ['server.middleware']: Repository['server']['middleware'];
        ['server.browser']: Repository['server']['browser'];
        ['server.watch.files']: Repository['server']['watch']['files'];
        ['server.middleware.dev']: Repository['server']['middleware']['dev'];
        ['server.middleware.hot']: Repository['server']['middleware']['hot'];
        ['server.middleware.proxy']: Repository['server']['middleware']['proxy'];
        ['server.browser.indicator']: Repository['server']['browser']['indicator'];
        ['server.browser.overlay']: Repository['server']['browser']['overlay'];
        ['server.browser.log']: Repository['server']['browser']['log'];
        ['server.dev.url']: Repository['server']['dev']['url'];
        ['server.proxy.url']: Repository['server']['proxy']['url'];
    };
    // (undocumented)
    export type TermColor = `#${string}` | `black` | `red` | `green` | `yellow` | `blue` | `magenta` | `cyan` | `white` | `gray` | `grey` | `blackBright` | `redBright` | `greenBright` | `yellowBright` | `blueBright` | `magentaBright` | `cyanBright` | `whiteBright`;
    // (undocumented)
    export type ThemeColorsKeyMap = {
        [C in keyof Repository['theme']['colors'] as `theme.colors.${C & string}`]: Repository['theme']['colors'][C];
    };
    // (undocumented)
    export type ThemeKeyMap = {
        [K in keyof Repository['theme'] as `theme.${K & string}`]: Repository['theme'][K];
    };
        {};
}

// @public (undocumented)
interface tap<T = Framework> {
    // (undocumented)
    (fn: (app: Framework) => any, bound?: boolean): T;
}

// @public
const tap: tap;

// @public
export interface Tapable<P extends any[] = [Framework], T = any> extends Factory<[P], T> {
    // (undocumented)
    (this: P, ...args: P): T;
}

declare namespace ts {
    export {
        read_2 as read
    }
}

// @public (undocumented)
function when(test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;

// @public (undocumented)
interface when {
    // (undocumented)
    (test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;
}

// @public (undocumented)
const write: (file: string, data: any) => Promise<void>;

// @public (undocumented)
const write_2: (file: string, data: any) => Promise<void>;

declare namespace yaml {
    export {
        read_3 as read,
        write_2 as write
    }
}

```
