"use strict";(self.webpackChunk_roots_bud_docs=self.webpackChunk_roots_bud_docs||[]).push([[65972],{65854:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return u},assets:function(){return p},toc:function(){return c},default:function(){return d}});var a=n(87462),l=n(63366),o=(n(67294),n(3905)),i=(n(19055),["components"]),r={slug:"release-v5.0.0",title:"Release: v5.0.0",description:"Release notes for v5.0.0",author:"Kelly Mears",author_title:"Lead developer",author_url:"https://github.com/kellymears",author_image_url:"https://avatars.githubusercontent.com/u/397606?v=4",tags:["release"]},s=void 0,u={permalink:"/blog/release-v5.0.0",source:"@site/blog/release-5.0.0.mdx",title:"Release: v5.0.0",description:"Release notes for v5.0.0",date:"1970-01-01T00:00:00.000Z",formattedDate:"January 1, 1970",tags:[{label:"release",permalink:"/blog/tags/release"}],readingTime:2.185,truncated:!0,authors:[{name:"Kelly Mears",title:"Lead developer",url:"https://github.com/kellymears",imageURL:"https://avatars.githubusercontent.com/u/397606?v=4"}]},p={authorsImageUrls:[void 0]},c=[{value:"multi-compiler",id:"multi-compiler",children:[],level:3},{value:"You can now use Webpack plugins directly",id:"you-can-now-use-webpack-plugins-directly",children:[],level:3},{value:"More information",id:"more-information",children:[],level:2}],m={toc:c};function d(e){var t=e.components,n=(0,l.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Featuring multi-compiler, automatic extension detection, and more."),(0,o.kt)("p",null,"Bud v5 comes with a lot of changes. Please ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/roots/bud/compare/v4.6.0...v5.0.0"},"review the diff to see what's changed"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The most important change"),"\nYou no longer need to explicitly require an extension in your configuration file or call ",(0,o.kt)("inlineCode",{parentName:"p"},"bud.use")," to load it. Bud will automatically load the extensions you have installed. This feature can be circumvented with the ",(0,o.kt)("strong",{parentName:"p"},"--no-inject")," flag but this is not as well tested as the default behavior."),(0,o.kt)("img",{src:"/casts/build.svg"}),(0,o.kt)("h3",{id:"multi-compiler"},"multi-compiler"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"bud.make")," will create a new instance of Bud."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface make {\n  (name: string, tap?: (child: Bud) => any): Promise<Bud>\n}\n")),(0,o.kt)("p",null,"The easiest and cleanest way to use this feature is with a callback. ",(0,o.kt)("inlineCode",{parentName:"p"},"bud.make")," ultimately returns the parent compiler instance for fluent chaining."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='bud.config.ts'",title:"'bud.config.ts'"},"export default async (app: Bud) => {\n  app\n    .make('my-wordpress-theme', async (theme: Bud) => {\n      // theme is a fresh copy of Bud\n    })\n    .make('my-wordpress-plugin', async (plugin: Bud) => {\n      // plugin is a fresh copy of Bud\n    })\n  // you can call bud.make as many times as you please\n}\n")),(0,o.kt)("p",null,"You can retrieve a compiler you have already made with ",(0,o.kt)("inlineCode",{parentName:"p"},"bud.get"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"app.get('child')\n  .entry(...) // configuring the child\n")),(0,o.kt)("p",null,"Compile all the things:"),(0,o.kt)("img",{src:"/casts/multi-compiler.svg"}),(0,o.kt)("h3",{id:"you-can-now-use-webpack-plugins-directly"},"You can now use Webpack plugins directly"),(0,o.kt)("p",null,"Previously, a ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," property was required for bud extensions. This is still required for extension authors,\nsince it is nice for config maintainers and other extension authors to have a way to reference your\nextension should they want to change the way it works."),(0,o.kt)("p",null,"However, this is unnecessary for users who simply wish to use some Webpack plugin in their project."),(0,o.kt)("p",null,"Previously, a small amount of boilerplate was required to wrap a plugin:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"app.use({\n  name: 'my-webpack-plugin',\n  make: new MyWebpackPlugin(),\n})\n")),(0,o.kt)("p",null,"But, now you can just use a plugin. A name will be automatically generated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"app.use(new MyWebpackPlugin())\n")),(0,o.kt)("p",null,"A side effect of this is that extension authors can now make a single package that works both with vanilla webpack and bud:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const extension = {\n  name: 'my-bud-extension',\n  apply: compiler => {\n    // webpack apply\n  },\n  when: bud => bud.isProduction,\n  // register, boot, api, or any other extension prop\n}\n")),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"extension.apply")," overrules ",(0,o.kt)("inlineCode",{parentName:"p"},"extension.make"),". If you include both it won't throw an error or anything, but ",(0,o.kt)("inlineCode",{parentName:"p"},"extension.make")," won't produce a webpack plugin in the final config (unless you call it from ",(0,o.kt)("inlineCode",{parentName:"p"},"apply")," and use webpack apis to add the plugin manually)."),(0,o.kt)("h2",{id:"more-information"},"More information"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/releases/5.0.0"},"Read the release notes")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/roots/bud/compare/v4.6.0...v5.0.0"},"review the diff to see what's changed"))),(0,o.kt)("p",null,"Thanks ",(0,o.kt)("a",{parentName:"p",href:"/contributors"},"to all the contributors"),"!"))}d.isMDXComponent=!0}}]);