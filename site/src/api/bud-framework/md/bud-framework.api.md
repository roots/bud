## API Report File for "@roots/bud-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import type { Class } from 'type-fest';
import { Compiler as Compiler_2 } from 'webpack';
import { Configuration as Configuration_2 } from 'webpack';
import { Container } from '@roots/container';
import { DefaultMethods } from 'signale';
import { Framework as Framework_2 } from 'src';
import type { HighlightOptions } from '@roots/bud-support';
import type Ink from 'ink';
import { MultiCompiler } from 'webpack';
import { Options as Options_2 } from 'http-proxy-middleware';
import type { PrettyFormatOptions } from '@roots/bud-support';
import { PrettyFormatOptions as PrettyFormatOptions_2 } from 'pretty-format/build/types';
import { ProgressPlugin } from 'webpack';
import { Repository as Repository_2 } from '@roots/container';
import { RuleSetRule } from 'webpack';
import { Server as Server_2 } from 'http';
import { Signale } from '@roots/bud-support';
import { Signale as Signale_2 } from 'signale';
import { SignaleConfig } from 'signale';
import { SignaleOptions } from 'signale';
import { StatsCompilation } from 'webpack';
import { StatsError } from 'webpack';
import Webpack from 'webpack';
import * as Webpack_2 from 'webpack';

// @public
abstract class Abstract extends Service<Peers.Repository> {
    abstract hasPeerDependency(pkg: string): boolean;
    abstract peers: Peers.Interface;
    // (undocumented)
    abstract repository: Repository_2;
}

// @public
export interface Api<T = Record<string, (...args: unknown[]) => Framework_2>> extends Service<T> {
    // (undocumented)
    call: (name: string, ...args: any[]) => Promise<void>;
    // (undocumented)
    processQueue: () => Promise<void>;
    // @internal (undocumented)
    queue: Array<[string, ...any[]]>;
    // @internal (undocumented)
    trace: Array<[string, ...any[]]>;
}

// @public
interface Application extends Loose {
    // (undocumented)
    listen(on: string | number, cb: CallableFunction): Instance;
}

// @public
export interface AsyncFactory<P extends any[], T> {
    // (undocumented)
    (...args: P): Promise<T>;
}

// @public
export type AtLeastOne<Type = unknown> = Type | Type[];

// @public
export abstract class Bootstrapper<T = any> extends Container<T> {
    constructor(app: Framework);
    get app(): Framework;
    abstract ident?: string;
}

declare namespace Build {
    export {
        Build_2 as Interface,
        Build_3 as Abstract
    }
}
export { Build }

// @public
interface Build_2 extends Service {
    config: Webpack_2.Configuration;
    items: Items;
    loaders: Loaders;
    make(): Promise<Webpack_2.Configuration>;
    rules: Rules;
}

// @public
abstract class Build_3 extends Service {
    items: Item.Interface[];
    loaders: Loader.Interface[];
    abstract make: () => Webpack_2.Configuration;
    rules: Rule.Interface[];
}

declare namespace Cache_2 {
    export {
        CacheInterface as Interface,
        CacheAbstract as Abstract
    }
}
export { Cache_2 as Cache }

// @public
abstract class CacheAbstract extends Service implements CacheInterface {
    abstract directory: string;
    abstract hashFileContents(filePaths: Array<string>): Promise<string>;
    abstract version: string;
}

// @public
interface CacheInterface extends Service {
    directory: string;
    hashFileContents(str: Array<string>): Promise<string>;
    version: string;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Compiler" because one of its declarations is marked as @internal
//
// @public
export interface Compiler extends Service {
    before(): any;
    callback(err: StatsError, stats: StatsCompilation): void;
    compile(): Promise<any>;
    instance: Compiler.Instance;
    isCompiled: boolean;
    progress: Compiler.Progress;
    stats: StatsCompilation;
}

// @internal
export namespace Compiler {
    // (undocumented)
    export type Config = Configuration_2;
    // (undocumented)
    export type Instance = Compiler_2 | MultiCompiler;
    // (undocumented)
    export type Progress = any;
    // (undocumented)
    export namespace Progress {
        // (undocumented)
        export type Handler = ProgressPlugin['handler'];
    }
}

// @public
interface CompilerPlugin<Plugin = any, Options = Record<string, any>> extends Module_2 {
    apply?: CallableFunction;
    make?: Maybe<[Container<Options>, Framework, Signale], Plugin>;
}

// @public
export interface Configuration {
    // Warning: (ae-forgotten-export) The symbol "CompilerConfig" needs to be exported by the entry point index.d.ts
    build: CompilerConfig;
    cache: {
        type?: 'filesystem' | 'memory' | false;
    };
    // (undocumented)
    cli?: {
        args: Record<string, any>;
        argv: Array<string>;
        flags: Record<string, any>;
        raw: Array<Record<string, string>>;
        metadata: Record<string, Record<string, any>>;
    };
    extension: Index<any>;
    features: {
        cache?: boolean;
        dashboard?: boolean;
        clean?: boolean;
        hash?: boolean;
        html?: boolean;
        inject?: boolean;
        install?: boolean;
        log?: boolean;
        manifest?: boolean;
        splitChunks?: boolean;
    };
    fileFormat: string;
    hashFormat: string;
    location: Locations;
    log?: {
        level?: 'v' | 'vv' | 'vvv' | 'vvvv';
    };
    mode: 'production' | 'development';
    name: string;
    patterns: Record<string, RegExp>;
    server: Server.Configuration;
    theme: {
        spacing: number;
        colors: {
            foreground: TermColor;
            faded: TermColor;
            primary: TermColor;
            primaryAlt: TermColor;
            error: TermColor;
            errorAlt: TermColor;
            warning: TermColor;
            success: TermColor;
            accent: TermColor;
            flavor: TermColor;
        };
        screens: [
        [
        number,
        number
        ],
        [
        number,
        number
        ],
        [
        number,
        number
        ],
        [
        number,
        number
        ]
        ];
        columns: number;
        maxWidth: number;
        maxHeight: number;
    };
}

// @public
interface Configuration_3 {
    browser: {
        log: boolean;
        indicator: boolean;
        overlay: boolean;
    };
    disableHostCheck?: boolean;
    filename?: string;
    headers?: Index<string>;
    host: string;
    index?: string;
    methods?: string[];
    middleware: Index<boolean>;
    mimeTypes?: {
        [type: string]: string;
    };
    port: number;
    proxy: Options_2;
    publicPath?: string;
    watch: {
        files: string[];
    };
}

// @public
export type Constructor = new (options: Options) => Framework;

// @public
interface ConstructorOptions {
    loader: Maybe<[Framework], Loader.Interface>;
    options?: Maybe<[Framework], Options_3>;
}

// @public
export interface Dashboard extends Service {
    instance: Ink.Instance;
    render(Component: any, title?: string): void;
    run(): void;
}

// @public
export interface Dependencies extends Service {
    client: any;
    install(dependencies: {
        name: string;
        version: string;
    }[]): Promise<void>;
}

// @public
export interface Env extends Container {
    getPublicEnv(): Index<any>;
}

declare namespace Extension {
    export {
        Name,
        CompilerPlugin,
        Module_2 as Module
    }
}
export { Extension }

// @public
export interface Extensions extends Service {
    add(extension: CompilerPlugin | Module_2): Promise<void>;
    bootExtensions(): Promise<void>;
    // (undocumented)
    enqueue(extension: CompilerPlugin | Module_2): void;
    make(): {
        [key: string]: any;
        apply: CallableFunction;
    }[];
    // (undocumented)
    processQueue(): Promise<void>;
    queue: Array<CompilerPlugin | Module_2>;
    registerExtensions(): Promise<void>;
}

// @public
export interface Factory<P extends any[], T> {
    // (undocumented)
    (...args: P): T;
}

// @public
interface Factory_2 {
    // (undocumented)
    (app: Framework): LoaderInterface;
}

// @public
export abstract class Framework {
    constructor(options: Options);
    api: Api;
    await(...messages: any[]): this;
    bindMethod: any;
    build: Build.Interface;
    cache: Cache_2.Interface;
    children: Container<Record<string, Framework>>;
    // Warning: (ae-forgotten-export) The symbol "close" needs to be exported by the entry point index.d.ts
    close: close_2;
    compiler: Compiler;
    complete(...messages: any[]): this;
    // Warning: (ae-forgotten-export) The symbol "container" needs to be exported by the entry point index.d.ts
    container: container;
    dashboard: Dashboard;
    debug(...messages: any[]): this;
    dependencies: Dependencies;
    // (undocumented)
    dump(obj: any, options?: PrettyFormatOptions & HighlightOptions & {
        prefix: string;
    }): Framework;
    env: Env;
    error(...messages: any[]): this;
    extensions: Extensions;
    // Warning: (ae-forgotten-export) The symbol "get" needs to be exported by the entry point index.d.ts
    get: get;
    get hasChildren(): boolean;
    hooks: Hooks;
    // @internal
    abstract implementation: Constructor;
    info(...messages: any[]): this;
    get isChild(): boolean;
    get isDevelopment(): boolean;
    get isProduction(): boolean;
    get isRoot(): boolean;
    // Warning: (ae-forgotten-export) The symbol "methods" needs to be exported by the entry point index.d.ts
    json: typeof methods.json;
    // Warning: (ae-forgotten-export) The symbol "lifecycle" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    lifecycle: lifecycle;
    log(...messages: any[]): this;
    logger: Logger;
    // Warning: (ae-forgotten-export) The symbol "make" needs to be exported by the entry point index.d.ts
    make: make;
    // Warning: (ae-forgotten-export) The symbol "maybeCall" needs to be exported by the entry point index.d.ts
    maybeCall: maybeCall;
    // Warning: (ae-forgotten-export) The symbol "mixin" needs to be exported by the entry point index.d.ts
    mixin: typeof mixin;
    get mode(): Mode;
    set mode(mode: Mode);
    get name(): string;
    set name(name: string);
    options: Options;
    // Warning: (ae-forgotten-export) The symbol "path" needs to be exported by the entry point index.d.ts
    path: path;
    // Warning: (ae-forgotten-export) The symbol "pipe" needs to be exported by the entry point index.d.ts
    pipe: pipe;
    project: Project.Interface;
    root: Framework | null;
    // Warning: (ae-forgotten-export) The symbol "sequence" needs to be exported by the entry point index.d.ts
    sequence: sequence;
    // (undocumented)
    get server(): Server.Interface;
    set server(server: Server.Interface);
    _server: Server.Interface;
    services: Services;
    // Warning: (ae-forgotten-export) The symbol "setPath" needs to be exported by the entry point index.d.ts
    setPath: setPath;
    store: Container;
    success(...messages: any[]): this;
    // Warning: (ae-forgotten-export) The symbol "tap" needs to be exported by the entry point index.d.ts
    tap: tap;
    time(...messages: any[]): this;
    timeEnd(...messages: any[]): this;
    ts: typeof methods.ts;
    usingTsNode: boolean;
    warn(...messages: any[]): this;
    // Warning: (ae-forgotten-export) The symbol "when" needs to be exported by the entry point index.d.ts
    when: when;
    yml: typeof methods.yaml;
}

// @public
export interface Hooks extends Service<Hooks.Repository> {
    filter<T = any>(id: Hooks.Name, seed?: any): T;
    on(id: Hooks.Name, callback: Hooks.Hook): Framework;
    promised<T = any>(id: `${Hooks.Name & string}`, value?: any): Promise<T>;
}

// @public
export namespace Hooks {
    // (undocumented)
    export namespace BuildHooks {
        // (undocumented)
        export interface Config extends Webpack_2.Configuration {
            // (undocumented)
            mode?: Mode;
            // (undocumented)
            module?: {
                noParse?: RegExp | RegExp[] | ((content: string) => boolean);
                parser: any;
                rules?: RulesOverride;
            };
            // (undocumented)
            optimization?: OptimizationOverride;
            // (undocumented)
            parallelism?: Webpack_2.Configuration['parallelism'];
        }
        // (undocumented)
        export type Dive<T, S> = {
            [K in keyof T as `build.${S & string}.${K & string}`]: T[K];
        };
        // (undocumented)
        export type Keys = `build` | `build.${keyof Config}` | keyof Dive<Config['output'], 'output'> | 'build.output.pathInfo' | keyof Dive<Config['module'], 'module'> | keyof Dive<Config['module']['rules'], 'module.rules'> | keyof Dive<Config['module']['rules']['oneOf'], 'module.rules.oneOf'> | 'build.module.rules.parser' | keyof Dive<Config['resolve'], 'resolve'> | keyof Dive<Config['resolveLoader'], 'resolveLoader'> | 'build.cache.name' | 'build.cache.cacheLocation' | 'build.cache.cacheDirectory' | 'build.cache.hashAlgorithm' | 'build.cache.managedPaths' | 'build.cache.version' | 'build.cache.type' | 'build.cache.buildDependencies' | keyof Dive<Config['experiments'], 'experiments'> | keyof Dive<Config['watchOptions'], 'watchOptions'> | keyof Dive<Config['performance'], 'performance'> | keyof Dive<Config['optimization'], 'optimization'> | keyof Dive<Config['optimization']['splitChunks'], 'optimization.splitChunks'> | keyof Dive<Config['optimization']['splitChunks']['cacheGroups'], 'optimization.splitChunks.cacheGroups'> | keyof Dive<Config['optimization']['splitChunks']['cacheGroups']['vendor'], 'optimization.splitChunks.cacheGroups.vendor'>;
        // (undocumented)
        export type Optimization = Webpack_2.Configuration['optimization'];
        // (undocumented)
        export interface OptimizationOverride extends Optimization {
            // (undocumented)
            splitChunks: {
                cacheGroups: any;
            };
        }
        // (undocumented)
        export type Rules = Webpack_2.Configuration['module']['rules'];
        // (undocumented)
        export interface RulesOverride extends Rules {
            // (undocumented)
            oneOf: Webpack_2.RuleSetRule;
        }
            {};
    }
    export type Hook<T = any> = ((value?: T) => T) | T;
    // (undocumented)
    export type ItemKeys = `item` | `item.${keyof Items & string}` | `item.${keyof Items & string}.loader` | `item.${keyof Items & string}.options` | `item.${keyof Items & string}.options.${string}`;
    // (undocumented)
    export type Key = `${keyof Repository}`;
    export type Keys = keyof {
        [K in (keyof Modules & string) | (keyof Plugins & string) as `extension` | `extension.${K & string}` | `extension.${K}.${`${(keyof Modules & string) | (keyof Plugins & string)}` | (`${(keyof Modules & string) | (keyof Plugins & string)}.${string}` & string)}`]: Extension.Module;
    };
    // (undocumented)
    export type LoaderKeys = `loader` | `loader.${keyof Loaders & string}`;
    // (undocumented)
    export type LocationKeys = `location.${keyof Locations & string}`;
    // @internal (undocumented)
    export type Name = `event.build.make.before` | `event.build.make.after` | `event.compiler.before` | `event.compiler.after` | `event.compiler.done` | `compiler.stats` | `compiler.error` | `${ItemKeys}` | `${LocationKeys}` | `${LoaderKeys}` | `${Keys}` | `${RuleKeys}` | `${BuildHooks.Keys}`;
    // (undocumented)
    export type PromiseHook<T = any> = (value?: T) => Promise<T>;
    // Warning: (ae-incompatible-release-tags) The symbol "Repository" is marked as @public, but its signature references "Name" which is marked as @internal
    export type Repository = {
        [K in Name as `${K & string}`]?: Hook[];
    };
    // (undocumented)
    export type RuleKeys = `rule` | `rule.${keyof Rules & string}` | `rule.${keyof Rules & string}.${keyof Webpack_2.RuleSetRule & string}` | `rule.${keyof Rules & string}.${keyof Webpack_2.RuleSetRule & `options` & string}.${string}`;
        {};
}

// @public
export type Index<T = any> = {
    [key: string]: T;
};

// @public
interface Instance extends Server_2 {
}

// @public
interface Interface extends Service {
    application: Application;
    assets: string[];
    close(): any;
    config: Configuration['server'];
    getWatchedFiles(): Promise<Array<string>>;
    inject(): void;
    instance: Instance;
    middleware: Middleware;
    run(): Promise<this>;
    watcher: {
        [key: string]: any;
        close: CallableFunction;
        on: CallableFunction;
    };
}

// @public
interface Interface_2 {
    app: Framework;
    discover(type: 'dependencies' | 'devDependencies'): Promise<this>;
    getManifest(name: string): Promise<Record<string, any>>;
    getPackageManifestPath(name: string): Promise<string>;
    isExtension(name: string): boolean;
}

// @public
interface Interface_3 extends Service {
    // (undocumented)
    [key: string]: any;
    buildProfile(): Promise<any>;
    buildProfile(): Promise<any>;
    hasPeerDependency(pkg: string): boolean;
    peers: Peers.Interface;
    writeProfile(): Promise<any>;
}

declare namespace Item {
    export {
        Item_2 as Interface,
        Item_3 as Abstract,
        Options_3 as Options,
        ConstructorOptions,
        Output
    }
}
export { Item }

// @public
interface Item_2 {
    loader: Factory<[Framework], Loader.Interface>;
    make(app: Framework): Output;
    mergeOptions(options: Options_3, app: Framework): void;
    options: Options_3;
    setLoader(factory: Maybe<[Framework], Loader.Interface>): void;
    setOptions(factory: Maybe<[Framework], Options_3>): void;
}

// @public
abstract class Item_3 {
    abstract loader: Factory<[Framework], Loader.Interface>;
    abstract make(app: Framework): Output;
    abstract mergeOptions(options: Options_3, app: Framework): void;
    abstract options: Factory<[Framework], Options_3>;
    abstract setLoader(factory: Maybe<[Framework], Loader.Interface>): void;
    abstract setOptions(factory: Maybe<[Framework], Options_3>): void;
}

// @public @virtual
export interface Items extends Partial<Index<Item.Interface>> {
}

declare namespace json {
    export {
        read_2 as read,
        write
    }
}

declare namespace Loader {
    export {
        LoaderInterface as Interface,
        LoaderAbstract as Abstract,
        Factory_2 as Factory
    }
}
export { Loader }

// @public
abstract class LoaderAbstract implements LoaderInterface {
    abstract make(app: Framework): string;
    abstract normalizeInput<T = any>(input: Maybe<[Framework], T>): Factory<[Framework], T>;
    abstract src: Factory<[Framework], string>;
}

// @public
interface LoaderInterface {
    make(app: Framework): string;
    normalizeInput<T = any>(input: Maybe<[Framework], T>): Factory<[Framework], T>;
    src: Factory<[Framework], string>;
}

// @public @virtual
export interface Loaders extends Partial<Index<Loader.Interface>> {
}

// @public @virtual
export interface Locations extends Partial<Record<string, string>> {
    // (undocumented)
    [key: string]: string;
    // (undocumented)
    dist?: string;
    // (undocumented)
    project?: string;
    // (undocumented)
    src?: string;
}

// @public
export class Logger {
    constructor(app: Framework);
    // Warning: (ae-forgotten-export) The symbol "INSTANCE_CONFIG" needs to be exported by the entry point index.d.ts
    config: INSTANCE_CONFIG;
    get context(): Array<string>;
    get enabled(): boolean;
    get flags(): Record<string, any>;
    instance: Signale_2;
    // (undocumented)
    instantiate(): void;
    get interactive(): boolean;
    get level(): string;
    // (undocumented)
    makeInstance(options?: SignaleOptions, config?: SignaleConfig): Signale_2<DefaultMethods>;
    // (undocumented)
    options: SignaleOptions;
    scoped(...scope: Array<string>): Signale_2<DefaultMethods>;
    secrets: Array<string>;
    stream: (NodeJS.WriteStream & {
        fd: 1;
    })[];
}

// @public
export interface Loose {
    // (undocumented)
    [key: string]: any;
}

// @public
export type Maybe<A extends any[], T> = T | Factory<A, T>;

// @public
interface Middleware {
    // (undocumented)
    [key: string]: any;
}

// @public
export type Mode = 'production' | 'development';

// @public @deprecated
export interface Module<P = any, O = any> extends Extension.Module<O> {
}

// @public
interface Module_2<Options = any> extends Loose {
    api?: Maybe<[Framework], Record<string, any>>;
    boot?: Factory<[Framework, Signale], any>;
    mixin?: (app: Framework) => Promise<Record<string, any>>;
    name?: Name;
    options?: Maybe<[Framework], Options>;
    register?: Factory<[Framework, Signale], any>;
    when?: Maybe<[Framework, Container<Options>], boolean>;
}

// @public @virtual
export interface Modules extends Partial<Index<Extension.Module>> {
}

// @public
type Name = `${(keyof Modules & string) | (keyof Plugins & string)}`;

// @public (undocumented)
export interface Options {
    // @internal (undocumented)
    childOf?: Framework;
    config?: Partial<Configuration>;
    extensions?: () => Record<string, Extension.Module | Extension.CompilerPlugin>;
    services?: Services;
}

// @public
interface Options_3 {
    // (undocumented)
    [key: string]: any;
}

// @public
interface Options_4 extends Partial<{
    test: Maybe<Array<Framework>, RegExp>;
    use: Maybe<Array<Framework>, Array<Item.Interface>>;
    exclude: Maybe<Array<Framework>, RegExp>;
    type: Maybe<Array<Framework>, string>;
    parser: Maybe<Array<Framework>, Parser>;
    generator: Maybe<Array<Framework>, any>;
}> {
}

// @public
interface Output {
    loader: string;
    options?: Options_3;
}

// @public
interface Output_2 extends Partial<{
    test: RegExp;
    use?: {
        loader: string;
        options?: {
            [key: string]: any;
        };
    }[];
    exclude?: RegExp;
    type?: string;
    parser?: Parser;
    generator?: any;
}> {
}

// @public
interface Parser {
    // (undocumented)
    parse: (input?: string) => any;
}

// @public
interface Peer {
    name: string;
    source: string;
    type: 'dependencies' | 'devDependencies';
    ver: string;
}

declare namespace Peers {
    export {
        Peer,
        Repository,
        Interface_2 as Interface
    }
}
export { Peers }

// @public
export interface PluginInstance {
    apply: CallableFunction;
}

// @public @virtual
export interface Plugins extends Partial<Index<Extension.CompilerPlugin>> {
}

declare namespace Project {
    export {
        Abstract,
        Interface_3 as Interface
    }
}
export { Project }

// @public (undocumented)
function read(path: string): Promise<any>;

// @public (undocumented)
const read_2: (file: string) => Promise<any>;

// @public (undocumented)
const read_3: (file: string) => Promise<any>;

// @public
interface Repository {
    // (undocumented)
    [key: string]: any;
}

declare namespace Rule {
    export {
        Rule_2 as Interface,
        Rule_3 as Abstract,
        Parser,
        Options_4 as Options,
        Output_2 as Output
    }
}
export { Rule }

// @public
interface Rule_2 {
    getExclude(app: Framework): Output_2['exclude'];
    getGenerator(app: Framework): any;
    getParser(app: Framework): Parser;
    getTest(app: Framework): RegExp;
    getType(app: Framework): Output_2['type'];
    getUse(app: Framework): Item.Interface[];
    make(app: Framework): Output_2 | RuleSetRule;
    setExclude(exclude: Maybe<[Framework], RegExp>): void;
    setGenerator(Generator: Maybe<[Framework], any>): void;
    setParser(parser: Maybe<[Framework], Parser>): void;
    setTest(test: Maybe<[Framework], RegExp>): void;
    setType(type: Maybe<[Framework], string>): void;
    setUse(use: Maybe<[Framework], Item.Interface[]>): void;
    test?(app?: Framework): RuleSetRule['test'];
    use?(app?: Framework): Item.Interface[];
}

// @public
abstract class Rule_3 {
    abstract getExclude(app: Framework): Output_2['exclude'];
    abstract getGenerator(app: Framework): any;
    abstract getParser(app: Framework): Parser;
    abstract getTest(app: Framework): RegExp;
    abstract getType(app: Framework): Output_2['type'];
    abstract getUse(app: Framework): Item.Interface[];
    abstract make(app: Framework): Output_2 | RuleSetRule;
    abstract setExclude(exclude: Maybe<[Framework], RegExp>): void;
    abstract setGenerator(Generator: Maybe<[Framework], any>): void;
    abstract setParser(parser: Maybe<[Framework], Parser>): void;
    abstract setTest(test: Maybe<[Framework], RegExp>): void;
    abstract setType(type: Maybe<[Framework], string>): void;
    abstract setUse(use: Maybe<[Framework], Item.Interface[]>): void;
    abstract test?(app?: Framework): RuleSetRule['test'];
    abstract use?(app?: Framework): Item.Interface[];
}

// @public @virtual
export interface Rules extends Partial<Index<Rule.Interface>> {
}

declare namespace Server {
    export {
        Application,
        Instance,
        Middleware,
        Options_2 as ProxyOptions,
        Interface,
        Configuration_3 as Configuration
    }
}
export { Server }

// @public
export abstract class Service<Repository = Record<string, any>> extends Bootstrapper<Repository> {
    // @virtual
    boot?(app: Framework): Promise<any>;
    // @virtual
    booted?(app: Framework): Promise<any>;
    // @virtual
    bootstrap?(app: Framework): Promise<any>;
    // @virtual
    bootstrapped?(app: Framework): Promise<any>;
    dump(options?: PrettyFormatOptions_2): void;
    ident?: string;
    log(type: string, ...messages: any[]): this;
    get logger(): Logger['instance'];
    // @virtual
    register?(app: Framework): Promise<any>;
    // @virtual
    registered?(app: Framework): Promise<any>;
}

// @public @virtual
export interface Services extends Partial<Record<string, new (app: Framework) => Service>> {
}

// @public
export class Store<T = Configuration> extends Service<T> {
    // @override (undocumented)
    get<T = any>(path: keyof Repository_3): T;
    ident: string;
    // Warning: (ae-forgotten-export) The symbol "Repository" needs to be exported by the entry point index.d.ts
    repository: Repository_3;
}

// @public
export interface Tapable<P extends any[] = [Framework], T = any> extends Factory<[P], T> {
    // (undocumented)
    (this: P, ...args: P): T;
}

declare namespace ts {
    export {
        read
    }
}

// @public (undocumented)
const write: (file: string, data: any) => Promise<void>;

// @public (undocumented)
const write_2: (file: string, data: any) => Promise<void>;

declare namespace yaml {
    export {
        read_3 as read,
        write_2 as write
    }
}

// Warnings were encountered during analysis:
//
// src/Configuration.ts:263:7 - (ae-forgotten-export) The symbol "TermColor" needs to be exported by the entry point index.d.ts

```
