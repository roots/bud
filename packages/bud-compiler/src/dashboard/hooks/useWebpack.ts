import {useState, useEffect} from 'react'
import {useProgress} from './useProgress'

import fs from 'fs-extra'
import {resolve} from 'path'

import express from 'express'
import devMiddleware from 'webpack-dev-middleware'
import hotClient from 'webpack-hot-client'
import proxyMiddleware from 'http-proxy-middleware'
import WebpackDevServer from 'webpack-dev-server'

type Results = {
  error?: any
  stats?: any
}

type Build = any

/**
 * Hook: useWebpack
 *
 * @prop {Bud} bud
 */
const useWebpack = bud => {
  /**
   * Query bud for mode settings.
   */
  const [hot] = useState(bud.features.enabled('hot'))
  const [watch] = useState(bud.features.enabled('dev'))

  /**
   * Webpack callback
   *
   * This is fired when webpack finishes each round of compilation.
   *
   * This callback is not utilized when running in hot mode. That is
   * handled in the useHotSyncServer hook and is managed by webpack
   * dev server middleware.
   */
  const webpackCallback = (err, stats) => {
    const results: Results = {}

    /**
     * Add webpack compiler errors to state.
     */
    if (err) {
      results.error = err
    }

    /**
     * Add webpack compiler stats to state
     */
    if (stats) {
      results.stats = stats.toJson({
        version: true,
        hash: true,
        time: true,
        assets: true,
        errors: true,
        warnings: true,
        chunks: false,
        modules: false,
        entrypoints: false,
        assetsByChunkName: false,
        logging: false,
        children: false,
        namedChunkGroups: false,
      })
    }

    setBuild(results)
  }

  /**
   * Add progress plugin to state.
   */
  const {progress, percentage, message} = useProgress(bud)
  const [progressApplied, setProgressPluginApplied] = useState(null)
  useEffect(() => {
    if (progress) {
      progress.apply(bud.compiler)
      setProgressPluginApplied(true)
    }
  }, [progress, bud])

  /**
   * Run webpack compiler and log output to state.
   */
  const [build, setBuild] = useState<Build>(null)
  const [webpackRunning, setWebpackRunning] = useState(null)
  const [client, setClient] = useState(null)
  const [server, setServer] = useState(null)
  useEffect(() => {
    if (progressApplied && !webpackRunning) {
      setServer(
        new WebpackDevServer(bud.compiler, {
          hot: true,
          port: 3000,
          inline: true,
          overlay: true,
          publicPath: bud.dist(),
          disableHostCheck: true,
          transportMode: 'ws',
          host: 'sage.valet',
        }),
      )
    }
  }, [progressApplied, webpackRunning, hot, watch, bud])

  useEffect(() => {
    server && fs.outputFile(bud.dist('hot'), `http://localhost:3000`)
  }, [server, percentage])

  /**
   * Stats state variables consumed by application.
   */
  const [assets, setAssets] = useState([])
  const [warnings, setWarnings] = useState([])
  const [errors, setErrors] = useState([])
  const [hash, setHash] = useState(null)
  const [time, setTime] = useState(null)

  /**
   * Assets generated by webpack compiler.run or webpack compiler.watch
   */
  useEffect(() => {
    build?.stats?.assets && setAssets(build.stats.assets)
    build?.stats?.warnings && setWarnings(build.stats.warnings)
    build?.stats?.errors && setErrors(build.stats.errors)
    build?.stats?.hash && setHash(build.stats.hash)
    build?.stats?.time && setTime(build.stats.time)
  }, [build])

  /**
   * For convenience set a boolean conditional state variable
   * for tracked build stats. This affords not having to
   * litter length > 0 checks throughout the rest of the application.
   */
  const [hasAssets, setHasAssets] = useState(false)
  useEffect(() => {
    if (assets && assets.length > 0) {
      setHasAssets(true)
    }
  }, [assets])

  const [hasWarnings, setHasWarnings] = useState(false)
  useEffect(() => {
    if (warnings && warnings.length > 0) {
      setHasWarnings(true)
    }
  }, [warnings])

  const [hasErrors, setHasErrors] = useState(false)
  useEffect(() => {
    if (errors && errors.length > 0) {
      setHasErrors(true)
    }
  }, [errors])

  const [hasHash, setHasHash] = useState(false)
  useEffect(() => {
    if (hash) {
      setHasHash(true)
    }
  }, [hash])

  const [hasTime, setHasTime] = useState(false)
  useEffect(() => {
    if (time) {
      setHasTime(true)
    }
  }, [time])

  /**
   * Build needs to have assets/errors present
   * before returning true for build.done even if the percentage is 100%.
   * This is because progress finishes slightly before the assets
   * finish processing into state and so only checking for % it is common
   * to end up with no asset logs rendered to the CLI before the application
   * exits.
   */
  const done = percentage === 1 && (hasAssets || hasErrors)
  const success = percentage === 1 && hasAssets && !hasErrors

  /**
   * Return state to consumers.
   */
  return {
    assets,
    client,
    hasAssets,
    errors,
    hasErrors,
    hash,
    hasHash,
    time,
    hasTime,
    warnings,
    hasWarnings,
    percentage,
    server,
    done,
    success,
    message,
  }
}

export {useWebpack}
