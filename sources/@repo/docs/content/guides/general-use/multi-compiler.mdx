---
title: Running multiple compilers
description: It is possible to configure more than one Webpack compiler from a single bud config.
sidebar_label: Multi-compiler
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CodeBlock from '@theme/CodeBlock'

:::info Experimental feature

This is a newer feature of bud.js. It is possible that this API will change in future releases. We suspect these changes will
be driven by the needs of users.

:::

It is possible to configure more than one Webpack compiler in a project.

For a single page app this isn't really that useful. However, for WordPress or a Symfony app &mdash; or anything with potentially
very different builds for different pages &mdash; it is potentially very useful.

## Creating child instances

To specify a new child instance, we can use [bud.make](/docs/bud.make). It is a function that accepts two parameters: a name for the instance
(so we can refer to it later), and a callback that is identical to the standard `bud.config.js` module-level function.

In this example we're creating two instances of bud: one for `theme` code and another for `plugin` code.

<Tabs
  groupId="lang"
  defaultValue="ts"
  values={[
    {label: 'Javascript', value: 'js'},
    {label: 'TypeScript', value: 'ts'},
  ]}>
  <TabItem value="js">

```js title="bud.config.mjs"
export default async app =>
  app
    .make('theme', async theme =>
      theme
        .setPath('@dist', 'dist/theme')
        .entry('theme', ['theme.js', 'theme.css']),
    )
    .make('plugin', async plugin =>
      plugin
        .setPath('@dist', 'dist/plugin')
        .entry('plugin', ['plugin.js', 'plugin.css']),
    )
```

  </TabItem>
  <TabItem value="ts">

```ts title='bud.config.mts'
import type {Bud} from '@roots/bud'

export default (app: Bud): void =>
  app
    .make('theme', async (theme: Bud): Promise<void> => {
      theme
        .setPath('@dist', 'dist/theme')
        .entry('theme', ['theme.js', 'theme.css'])
    })
    .make(
      'plugin',
      async (plugin: Bud): Promise<void> =>
        plugin
          .setPath('@dist', 'dist/plugin')
          .entry('plugin', ['plugin.js', 'plugin.css']),
    )
```

  </TabItem>
</Tabs>

## Using the `--target` flag

The other benefit is a potentially massive workflow improvement. Let's say that we have to work on the `theme` more often than the `plugin`.
With the above config we don't have to rebuild the `plugin` code again just to work on our `theme` code.

We can use the `bud` cli to only run the compiler we need using [the `--target` flag](/guides/cli/build).

```sh
$ yarn bud build --target theme
```

If you had more than two instances it might make sense to want to target more than one compiler, and `--target` supports that:

```sh
$ yarn bud build --target theme --target plugin
```

## Extensions

By default, all extensions will be applied to all compilers in the project.

You can use the `--no-inject` flag to prevent any extensions from being registered (except for core extensions).

In that case you will need to manually register the extensions you want to use per compiler:

```ts title='bud.config.compiler-a.mjs'
import BudPostCSS from '@roots/bud-postcss/extension'

export default async bud => {
  bud.make('theme', async theme => {
    bud
      .use(BudPostCSS)
      .setPath('@dist', 'dist/theme')
      .entry('theme', ['theme.css'])
  })
}
```

```ts title='bud.config.compiler-b.mjs'
import BudReact from '@roots/bud-react/extension'

export default async bud => {
  bud.make('plugin', async plugin => {
    bud
      .use(BudReact)
      .setPath('@dist', 'dist/plugin')
      .entry('plugin', ['plugin.js'])
  })
}
```

## Configuring manually registered extensions

When using [bud.use](/docs/bud.use) extensions will not be registered until after the config has been processed.

This matters when you want to configure an extension (like [@roots/bud-postcss](/extensions/bud-postcss)). In this case you should use `bud.extensions.add`:

```ts title='bud.config.extensions.mjs'
import BudPostCSS from '@roots/bud-postcss/extension'

export default async bud => {
  bud.make('plugin', async plugin => {
    await bud.extensions.add(BudPostCSS)
    plugin.postcss.setPluginOption('env', {stage: 0})
  })
}
```

## Using multiple config files

To keep your project well organized, you might consider using multiple bud configuration files to separate compilers.

```ts title='bud.config.theme.mjs'
export default async bud =>
  bud.make('theme', async theme =>
    theme
      .setPath('@dist', bud.path('dist/theme'))
      .entry('theme', ['@src/theme']),
  )
```

```ts title='bud.config.plugin.mjs'
export default async bud =>
  bud.make('plugin', async plugin =>
    plugin
      .setPath('@dist', bud.path('dist/plugin'))
      .entry('plugin', ['@src/plugin']),
  )
```
